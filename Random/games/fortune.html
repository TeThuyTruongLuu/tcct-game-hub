<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>L∆∞u tr·ªØ truy·ªán</title>
<!-- 	<script type="module">
		import { initializeApp } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-app.js";
		import { getFirestore } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-firestore.js";

		const firebaseConfig = {
			apiKey: "AIzaSyBtpLSSNBj9lHtzibLh5QSRAPg3iQ46Q3g",
			authDomain: "tcct-minigames.firebaseapp.com",
			projectId: "tcct-minigames",
			storageBucket: "tcct-minigames.firebasestorage.app",
			messagingSenderId: "604780847536",
			appId: "1:604780847536:web:f8015bde5ef469b04c7675",
			measurementId: "G-1GGDZR6VY5"
		};

		const app = initializeApp(firebaseConfig);
		const db = getFirestore(app);
		window.db = db;

		console.log("üî• Firebase 9+ ƒë√£ kh·ªüi t·∫°o!");
	</script> -->



    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #f7f1e3;
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
        }
        .container {
            width: 90%;
            max-width: 1000px;
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        }
		.input-container {
			display: flex;
			flex-direction: column;
			align-items: center;
			gap: 10px;
			margin-bottom: 15px;
			width: 100%;
		}

		input {
			width: 90%;
			max-width: 400px; /* Gi·ªõi h·∫°n ƒë·ªô r·ªông t·ªëi ƒëa ƒë·ªÉ tr√°nh qu√° to */
			padding: 10px;
			border: 1px solid #ccc;
			border-radius: 5px;
		}

		button {
			padding: 10px 20px;
			background-color: #6c5ce7;
			color: white;
			border: none;
			border-radius: 5px;
			cursor: pointer;
			font-size: 16px;
			font-weight: bold;
			white-space: nowrap;
		}

		button:hover {
			background-color: #5a4ae0;
		}

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
            background: white;
            border-radius: 5px;
            overflow: hidden;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 10px;
            text-align: left;
        }
        th {
            background-color: #dfe6e9;
        }
        .delete-btn {
            cursor: pointer;
            color: red;
            font-weight: bold;
        }
		.pagination {
			display: flex;
			justify-content: center;
			margin-top: 15px;
			gap: 5px;
		}

		.pagination button {
			padding: 8px 12px;
			border: 1px solid #6c5ce7;
			background-color: #f7f1e3;
			color: #6c5ce7;
			cursor: pointer;
			border-radius: 5px;
			font-size: 14px;
		}

		.pagination button.active {
			background-color: #6c5ce7;
			color: white;
		}

		.pagination button:hover {
			background-color: #5a4ae0;
			color: white;
		}

        @media (max-width: 600px) {
            table {
                display: block;
                overflow-x: auto;
                white-space: nowrap;
            }
			button {margin-top: 2vw;}
			td, th {
				word-wrap: break-word;
				white-space: normal;
			}
			td:nth-child(2) {
				min-width: 120px;
				max-width: 250px;
			}
			td:nth-child(3) {
				min-width: 70px;
				max-width: 100px;
			}

			.table-container {
				overflow-x: auto;
				display: block;
			}
        }
    </style>
</head>
<body>
    <div class="container">
        <h2>L∆∞u tr·ªØ truy·ªán</h2>
        <input type="text" id="storyLink" placeholder="Nh·∫≠p link truy·ªán (b·ªè 's' trong 'https')">
        <button onclick="fetchStory()">L∆∞u Truy·ªán</button>
		<br><br>
		<button onclick="randomStory()">Random Truy·ªán</button>
		<div>
			<input type="text" id="searchInput" placeholder="T√¨m ki·∫øm truy·ªán..." onkeyup="filterStories()">
			<select id="statusFilter" onchange="filterStories()">
				<option value="">T·∫•t c·∫£ tr·∫°ng th√°i</option>
				<option value="Ho√†n">Ho√†n</option>
				<option value="ƒêang c·∫≠p nh·∫≠t">ƒêang c·∫≠p nh·∫≠t</option>
			</select>
			<select id="tagFilter" onchange="filterStories()">
				<option value="">T·∫•t c·∫£ tag</option>
			</select>
		</div>

        <h3>Danh s√°ch truy·ªán ƒë√£ l∆∞u</h3>
        <table>
            <thead>
                <tr>
                    <th onclick="sortTable(0)">STT</th>
                    <th onclick="sortTable(1)">T√™n truy·ªán</th>
                    <th onclick="sortTable(2)">Tag</th>
                    <th>T√°c gi·∫£</th>
                    <th>Edit / Beta</th>
                    <th onclick="sortTable(3)">T√¨nh tr·∫°ng</th>
                    <th>Link</th>
                    <th>Review</th>
                    <th>X√≥a</th>
                </tr>
            </thead>
            <tbody id="storyTable"></tbody>
        </table>
		<div class="pagination" id="pagination"></div>
    </div>

    <script type="module">
		// üî• Import Firebase 9+
		import { initializeApp } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-app.js";
		import { getFirestore, collection, addDoc, getDocs, query, where, deleteDoc, doc } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-firestore.js";

		// üõ†Ô∏è C·∫•u h√¨nh Firebase
		const firebaseConfig = {
			apiKey: "AIzaSyBtpLSSNBj9lHtzibLh5QSRAPg3iQ46Q3g",
			authDomain: "tcct-minigames.firebaseapp.com",
			projectId: "tcct-minigames",
			storageBucket: "tcct-minigames.firebasestorage.app",
			messagingSenderId: "604780847536",
			appId: "1:604780847536:web:f8015bde5ef469b04c7675",
			measurementId: "G-1GGDZR6VY5"
		};

		// üî• Kh·ªüi t·∫°o Firebase
		const app = initializeApp(firebaseConfig);
		const db = getFirestore(app);
		const storiesCollection = collection(db, "stories");

		// üõ†Ô∏è IndexedDB setup
		const dbName = "StoryDB";
		let idb;

		function openDatabase() {
			let request = indexedDB.open(dbName, 1);
			request.onupgradeneeded = function (event) {
				idb = event.target.result;
				if (!idb.objectStoreNames.contains("stories")) {
					idb.createObjectStore("stories", { keyPath: "url" });
				}
			};
			request.onsuccess = function (event) {
				idb = event.target.result;
				loadStories();
			};
			request.onerror = function (event) {
				console.error("Database error:", event.target.error);
			};
		}

		// üöÄ L·∫•y d·ªØ li·ªáu truy·ªán t·ª´ link web
		async function fetchStory() {
			let inputField = document.getElementById("storyLink");
			let url = inputField.value.trim();
			inputField.value = url;

			if (!url) {
				alert("Vui l√≤ng nh·∫≠p link truy·ªán!");
				return;
			}

			try {
				let response = await fetch(url);
				let text = await response.text();
				let parser = new DOMParser();
				let doc = parser.parseFromString(text, "text/html");

				let title = doc.querySelector("h1")?.innerText || "Kh√¥ng r√µ";
				let defaultTag = title.match(/\[(.*?)\]/) ? title.match(/\[(.*?)\]/)[1] : "Kh√¥ng r√µ";
				let status = doc.querySelector("h1.p-title-value span")?.textContent.trim() || "Kh√¥ng r√µ";
				let author = "Kh√¥ng r√µ";
				let editor = "Kh√¥ng r√µ";

				doc.querySelectorAll("article.message-body.js-selectToQuote div").forEach(div => {
					let text = div.innerText.trim();
					let authorMatch = text.match(/T√°c gi·∫£:\s*(.+)|Author:\s*(.+)/i);
					if (authorMatch) author = authorMatch[1] || authorMatch[2];

					let editorMatch = text.match(/Editor:\s*(.+)|Edit:\s*(.+)/i);
					if (editorMatch) editor = editorMatch[1] || editorMatch[2];
				});

				editor = editor.replace(/^@/, "").trim();

				if (!url) {
					console.error("üö® L·ªói: Truy·ªán kh√¥ng c√≥ URL h·ª£p l·ªá!");
					alert("Kh√¥ng th·ªÉ l∆∞u truy·ªán v√¨ thi·∫øu URL.");
					return;
				}

				let story = {
					title,
					defaultTag,
					userTags: [],
					author,
					editor,
					status,
					url,
					review: []
				};

				await saveStory(story);
			} catch (error) {
				console.error("‚ùå L·ªói khi fetch truy·ªán:", error);
				alert("Kh√¥ng th·ªÉ l·∫•y d·ªØ li·ªáu t·ª´ link n√†y!");
			}
		}

		// üî• L∆∞u truy·ªán v√†o Firestore
		async function saveStoryToFirestore(story) {
			try {
				let q = query(storiesCollection, where("url", "==", story.url));
				let querySnapshot = await getDocs(q);

				if (!querySnapshot.empty) {
					console.log("‚ö† Truy·ªán ƒë√£ t·ªìn t·∫°i trong Firestore:", story.url);
					return;
				}

				let docRef = await addDoc(storiesCollection, story);
				console.log("üî• ƒê√£ l∆∞u truy·ªán v√†o Firestore v·ªõi ID:", docRef.id);
			} catch (error) {
				console.error("‚ùå L·ªói khi l∆∞u v√†o Firestore:", error);
			}
		}

		// üõ†Ô∏è L∆∞u truy·ªán v√†o IndexedDB
		function saveStoryToIndexedDB(story) {
			if (!idb) {
				console.warn("‚ö† IndexedDB ch∆∞a s·∫µn s√†ng.");
				return;
			}

			if (!story.url) {
				console.error("üö® L·ªói: Kh√¥ng th·ªÉ l∆∞u truy·ªán v√†o IndexedDB v√¨ thi·∫øu 'url'!");
				return;
			}

			let transaction = idb.transaction(["stories"], "readwrite");
			let store = transaction.objectStore("stories");

			let request = store.put(story);
			request.onsuccess = function () {
				console.log("‚úÖ ƒê√£ l∆∞u truy·ªán v√†o IndexedDB:", story.url);
			};
			request.onerror = function (event) {
				console.error("‚ùå L·ªói khi l∆∞u v√†o IndexedDB:", event.target.error);
			};
		}


		// üöÄ Load truy·ªán t·ª´ Firestore v√† IndexedDB
		async function loadStories() {
			let firestoreStories = await getDocs(storiesCollection);
			let stories = [];

			firestoreStories.forEach((doc) => {
				let story = doc.data();
				story.id = doc.id;
				stories.push(story);
			});

			let indexedDBStories = await loadStoriesFromIndexedDB();
			let mergedStories = [...stories];

			indexedDBStories.forEach((story) => {
				if (!stories.some(fStory => fStory.url === story.url)) {
					mergedStories.push(story);
				}
			});

			renderStories(mergedStories);
		}

		// üõ†Ô∏è Load truy·ªán t·ª´ IndexedDB
		function loadStoriesFromIndexedDB() {
			return new Promise((resolve, reject) => {
				if (!idb) {
					resolve([]);
					return;
				}

				let transaction = idb.transaction(["stories"], "readonly");
				let store = transaction.objectStore("stories");
				let request = store.getAll();

				request.onsuccess = function (event) {
					resolve(event.target.result);
				};

				request.onerror = function (event) {
					console.error("L·ªói khi t·∫£i t·ª´ IndexedDB:", event.target.error);
					resolve([]);
				};
			});
		}

		// üöÄ X√≥a truy·ªán kh·ªèi Firestore
		async function deleteStoryFromFirestore(storyId) {
			await deleteDoc(doc(db, "stories", storyId));
		}

		// üöÄ X√≥a truy·ªán kh·ªèi IndexedDB
		function deleteStoryFromIndexedDB(storyUrl) {
			let transaction = idb.transaction(["stories"], "readwrite");
			let store = transaction.objectStore("stories");
			store.delete(storyUrl);
		}

		// ‚úÖ Ch·∫°y
		openDatabase();
		window.fetchStory = fetchStory;
		
		function renderStories(stories) {
			let storyTable = document.getElementById("storyTable");
			storyTable.innerHTML = "";

			stories.forEach((story, index) => {
				let row = `
					<tr>
						<td>${index + 1}</td>
						<td>${story.title}</td>
						<td>${story.defaultTag}</td>
						<td>${story.author}</td>
						<td>${story.editor}</td>
						<td>${story.status}</td>
						<td><a href="${story.url}" target="_blank">Xem</a></td>
						<td contenteditable="true" onblur="updateReview('${story.url}', this.innerText)">
							${story.review ? story.review.join(", ") : ""}
						</td>
						<td class="delete-btn" onclick="deleteStory('${story.url}', '${story.id || ""}')">üóë</td>
					</tr>
				`;
				storyTable.innerHTML += row;
			});
		}

		window.renderStories = renderStories; // ƒê·∫£m b·∫£o c√≥ th·ªÉ g·ªçi t·ª´ loadStories()

    </script>
</body>
</html>
