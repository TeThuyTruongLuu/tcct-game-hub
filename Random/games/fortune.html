<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>L∆∞u tr·ªØ truy·ªán</title>
	<script type="module">
		import { db } from "../../js/index.js"; // L·∫•y Firestore t·ª´ index.js
		window.db = db; // G√°n db v√†o window ƒë·ªÉ g·ªçi t·ª´ HTML
	</script>

    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #f7f1e3;
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
        }
        .container {
            width: 90%;
            max-width: 1000px;
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        }
		.input-container {
			display: flex;
			flex-direction: column;
			align-items: center;
			gap: 10px;
			margin-bottom: 15px;
			width: 100%;
		}

		input {
			width: 90%;
			max-width: 400px; /* Gi·ªõi h·∫°n ƒë·ªô r·ªông t·ªëi ƒëa ƒë·ªÉ tr√°nh qu√° to */
			padding: 10px;
			border: 1px solid #ccc;
			border-radius: 5px;
		}

		button {
			padding: 10px 20px;
			background-color: #6c5ce7;
			color: white;
			border: none;
			border-radius: 5px;
			cursor: pointer;
			font-size: 16px;
			font-weight: bold;
			white-space: nowrap;
		}

		button:hover {
			background-color: #5a4ae0;
		}

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
            background: white;
            border-radius: 5px;
            overflow: hidden;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 10px;
            text-align: left;
        }
        th {
            background-color: #dfe6e9;
        }
        .delete-btn {
            cursor: pointer;
            color: red;
            font-weight: bold;
        }
		.pagination {
			display: flex;
			justify-content: center;
			margin-top: 15px;
			gap: 5px;
		}

		.pagination button {
			padding: 8px 12px;
			border: 1px solid #6c5ce7;
			background-color: #f7f1e3;
			color: #6c5ce7;
			cursor: pointer;
			border-radius: 5px;
			font-size: 14px;
		}

		.pagination button.active {
			background-color: #6c5ce7;
			color: white;
		}

		.pagination button:hover {
			background-color: #5a4ae0;
			color: white;
		}

        @media (max-width: 600px) {
            table {
                display: block;
                overflow-x: auto;
                white-space: nowrap;
            }
			button {margin-top: 2vw;}
			td, th {
				word-wrap: break-word;
				white-space: normal;
			}
			td:nth-child(2) {
				min-width: 120px;
				max-width: 250px;
			}
			td:nth-child(3) {
				min-width: 70px;
				max-width: 100px;
			}

			.table-container {
				overflow-x: auto;
				display: block;
			}
        }
    </style>
</head>
<body>
    <div class="container">
        <h2>L∆∞u tr·ªØ truy·ªán</h2>
        <input type="text" id="storyLink" placeholder="Nh·∫≠p link truy·ªán (b·ªè 's' trong 'https')">
        <button onclick="fetchStory()">L∆∞u Truy·ªán</button>
		<br><br>
		<button onclick="randomStory()">Random Truy·ªán</button>
		<div>
			<input type="text" id="searchInput" placeholder="T√¨m ki·∫øm truy·ªán..." onkeyup="filterStories()">
			<select id="statusFilter" onchange="filterStories()">
				<option value="">T·∫•t c·∫£ tr·∫°ng th√°i</option>
				<option value="Ho√†n">Ho√†n</option>
				<option value="ƒêang c·∫≠p nh·∫≠t">ƒêang c·∫≠p nh·∫≠t</option>
			</select>
			<select id="tagFilter" onchange="filterStories()">
				<option value="">T·∫•t c·∫£ tag</option>
			</select>
		</div>

        <h3>Danh s√°ch truy·ªán ƒë√£ l∆∞u</h3>
        <table>
            <thead>
                <tr>
                    <th onclick="sortTable(0)">STT</th>
                    <th onclick="sortTable(1)">T√™n truy·ªán</th>
                    <th onclick="sortTable(2)">Tag</th>
                    <th>T√°c gi·∫£</th>
                    <th>Edit / Beta</th>
                    <th onclick="sortTable(3)">T√¨nh tr·∫°ng</th>
                    <th>Link</th>
                    <th>Review</th>
                    <th>X√≥a</th>
                </tr>
            </thead>
            <tbody id="storyTable"></tbody>
        </table>
		<div class="pagination" id="pagination"></div>
    </div>

    <script>
		const dbName = "StoryDB";
		let idb;
		const channel = new BroadcastChannel("story_sync");
		const proxyUrl = "https://phong.tethuytruongluu1947.workers.dev/?url=";
		let storiesCollection;

		document.addEventListener("DOMContentLoaded", function () {
			if (window.db) {
				storiesCollection = window.db.collection("stories");
			} else {
				console.error("Firestore ch∆∞a ƒë∆∞·ª£c kh·ªüi t·∫°o!");
			}
		});


		// Kh·ªüi t·∫°o IndexedDB
		function openDatabase() {
			let request = indexedDB.open(dbName, 1);
			request.onupgradeneeded = function(event) {
				idb = event.target.result;
				if (!idb.objectStoreNames.contains("stories")) {
					idb.createObjectStore("stories", { keyPath: "url" });
				}
			};
			request.onsuccess = function(event) {
				idb = event.target.result;
				loadStories();
			};
			request.onerror = function(event) {
				console.error("Database error:", event.target.error);
			};
		}

		async function fetchStory() {
			let inputField = document.getElementById("storyLink");
			let url = inputField.value.trim();
			inputField.value = url;

			if (!url) {
				alert("Vui l√≤ng nh·∫≠p link truy·ªán!");
				return;
			}

			try {
				let response = await fetch(proxyUrl + encodeURIComponent(url));
				let text = await response.text();
				let parser = new DOMParser();
				let doc = parser.parseFromString(text, "text/html");

				let title = doc.querySelector("h1")?.innerText || "Kh√¥ng r√µ";
				let defaultTag = title.match(/\[(.*?)\]/) ? title.match(/\[(.*?)\]/)[1] : "Kh√¥ng r√µ";
				let status = doc.querySelector("h1.p-title-value span")?.textContent.trim() || "Kh√¥ng r√µ";
				let author = "Kh√¥ng r√µ";
				let editor = "Kh√¥ng r√µ";

				doc.querySelectorAll("article.message-body.js-selectToQuote div").forEach(div => {
					let text = div.innerText.trim();
					let authorMatch = text.match(/T√°c gi·∫£:\s*(.+)|Author:\s*(.+)/i);
					if (authorMatch) author = authorMatch[1] || authorMatch[2];

					let editorMatch = text.match(/Editor:\s*(.+)|Edit:\s*(.+)/i);
					if (editorMatch) editor = editorMatch[1] || editorMatch[2];
				});

				editor = editor.replace(/^@/, "").trim();

				let story = {
					title,
					defaultTag,
					userTags: [],
					author,
					editor,
					status,
					url,
					review: []
				};

				await saveStory(story); // ‚úÖ G·ªçi h√†m l∆∞u truy·ªán
			} catch (error) {
				console.error("Error fetching story:", error);
				alert("Kh√¥ng th·ªÉ l·∫•y d·ªØ li·ªáu t·ª´ link n√†y!");
			}
		}


		function saveStoryOffline(story) {
			let transaction = idb.transaction(["stories"], "readwrite"); // ‚úÖ S·ª≠a l·∫°i th√†nh idb
			let store = transaction.objectStore("stories");
			store.put(story);
		}

		async function loadStoriesFromFirestore() {
			try {
				let querySnapshot = await db.collection("stories").get();
				let stories = [];
				querySnapshot.forEach((doc) => {
					let story = doc.data();
					story.id = doc.id;
					stories.push(story);
				});
				console.log("üî• D·ªØ li·ªáu t·ª´ Firestore:", stories);
				return stories;
			} catch (error) {
				console.error("‚ùå L·ªói khi t·∫£i t·ª´ Firestore:", error);
				return [];
			}
		}

		function loadStoriesFromIndexedDB() {
			return new Promise((resolve, reject) => {
				if (!idb) {
					console.warn("IndexedDB ch∆∞a s·∫µn s√†ng, tr·∫£ v·ªÅ danh s√°ch r·ªóng.");
					resolve([]);
					return;
				}
				let transaction = idb.transaction(["stories"], "readonly");
				let store = transaction.objectStore("stories");
				let request = store.getAll();

				request.onsuccess = function(event) {
					console.log("D·ªØ li·ªáu t·ª´ IndexedDB:", event.target.result);
					resolve(event.target.result);
				};

				request.onerror = function(event) {
					console.error("L·ªói khi t·∫£i t·ª´ IndexedDB:", event.target.error);
					resolve([]);
				};
			});
		}

		async function loadStories() {
			let firestoreStories = await loadStoriesFromFirestore();
			let indexedDBStories = await loadStoriesFromIndexedDB();

			// G·ªôp d·ªØ li·ªáu: Tr√°nh tr√πng b·∫±ng c√°ch ki·ªÉm tra `url`
			let mergedStories = [...firestoreStories];
			indexedDBStories.forEach((story) => {
				if (!firestoreStories.some(fStory => fStory.url === story.url)) {
					mergedStories.push(story);
				}
			});

			// Hi·ªÉn th·ªã d·ªØ li·ªáu sau khi g·ªôp
			renderStories(mergedStories);
		}

		function renderStories(stories) {
			let storyTable = document.getElementById("storyTable");
			storyTable.innerHTML = "";

			stories.forEach((story, index) => {
				let row = `
					<tr>
						<td>${index + 1}</td>
						<td>${story.title}</td>
						<td>${story.status}</td>
						<td><button onclick="deleteStory('${story.url}', '${story.id || ''}')">X√≥a</button></td>
					</tr>
				`;
				storyTable.innerHTML += row;
			});

			updateTagFilter(stories);
		}

		async function deleteStoryFromFirestore(storyId) {
			let password = prompt("Nh·∫≠p m·∫≠t kh·∫©u admin ƒë·ªÉ x√≥a:");
			if (password !== "admin123") {
				alert("Sai m·∫≠t kh·∫©u!");
				return;
			}

			try {
				await db.collection("stories").doc(storyId).delete();
				console.log(`‚úÖ Truy·ªán c√≥ ID ${storyId} ƒë√£ b·ªã x√≥a kh·ªèi Firestore.`);
			} catch (error) {
				console.error("‚ùå L·ªói khi x√≥a truy·ªán t·ª´ Firestore:", error);
			}
		}


		function deleteStoryFromIndexedDB(storyUrl) {
			if (!idb) {
				console.warn("IndexedDB ch∆∞a s·∫µn s√†ng.");
				return;
			}

			let transaction = idb.transaction(["stories"], "readwrite");
			let store = transaction.objectStore("stories");
			let request = store.delete(storyUrl);

			request.onsuccess = function() {
				console.log(`Truy·ªán c√≥ URL ${storyUrl} ƒë√£ b·ªã x√≥a kh·ªèi IndexedDB.`);
			};

			request.onerror = function(event) {
				console.error("L·ªói khi x√≥a truy·ªán kh·ªèi IndexedDB:", event.target.error);
			};
		}

		async function deleteStory(storyUrl, storyId = null) {
			if (storyId) {
				await deleteStoryFromFirestore(storyId);
			}
			deleteStoryFromIndexedDB(storyUrl);
			loadStories(); // C·∫≠p nh·∫≠t UI
		}

		async function saveStoryToFirestore(story) {
			try {
				let querySnapshot = await db.collection("stories").where("url", "==", story.url).get();
				if (!querySnapshot.empty) {
					console.log("Truy·ªán ƒë√£ t·ªìn t·∫°i trong Firestore:", story.url);
					return;
				}

				let docRef = await db.collection("stories").add(story);
				console.log("üî• ƒê√£ l∆∞u truy·ªán v√†o Firestore v·ªõi ID:", docRef.id);
			} catch (error) {
				console.error("‚ùå L·ªói khi l∆∞u v√†o Firestore:", error);
			}
		}


		function saveStoryToIndexedDB(story) {
			if (!idb) {
				console.warn("IndexedDB ch∆∞a s·∫µn s√†ng.");
				return;
			}

			let transaction = idb.transaction(["stories"], "readwrite");
			let store = transaction.objectStore("stories");

			let request = store.put(story);
			request.onsuccess = function() {
				console.log("ƒê√£ l∆∞u truy·ªán v√†o IndexedDB:", story.url);
			};
			request.onerror = function(event) {
				console.error("L·ªói khi l∆∞u v√†o IndexedDB:", event.target.error);
			};
		}

		async function saveStory(story) {
			await saveStoryToFirestore(story); // L∆∞u l√™n Firestore
			saveStoryToIndexedDB(story); // L∆∞u v√†o IndexedDB
			loadStories(); // C·∫≠p nh·∫≠t UI
		}

		function updateTagFilter(stories) {
			let tagSet = new Set();
			stories.forEach(story => {
				tagSet.add(story.defaultTag);
				story.userTags.forEach(tag => tagSet.add(tag));
			});

			let tagFilter = document.getElementById("tagFilter");
			tagFilter.innerHTML = `<option value="">T·∫•t c·∫£ tag</option>`;
			tagSet.forEach(tag => {
				let option = document.createElement("option");
				option.value = tag;
				option.innerText = tag;
				tagFilter.appendChild(option);
			});
		}

		function filterStories() {
			let searchText = document.getElementById("searchInput").value.toLowerCase();
			let statusFilter = document.getElementById("statusFilter").value;
			let tagFilter = document.getElementById("tagFilter").value;

			let filteredStories = allStories.filter(story => {
				let matchesTitle = story.title.toLowerCase().includes(searchText);
				let matchesStatus = statusFilter ? story.status === statusFilter : true;
				let matchesTag = tagFilter ? (story.defaultTag === tagFilter || story.userTags.includes(tagFilter)) : true;
				return matchesTitle && matchesStatus && matchesTag;
			});

			renderStories(filteredStories);
		}

		let sortOrder = { column: null, asc: true };

		function sortTable(column) {
			let keyMap = ["stt", "title", "status"]; // X√°c ƒë·ªãnh key t∆∞∆°ng ·ª©ng
			let key = keyMap[column];

			if (sortOrder.column === key) {
				sortOrder.asc = !sortOrder.asc; // ƒê·∫£o ng∆∞·ª£c n·∫øu c√πng c·ªôt
			} else {
				sortOrder = { column: key, asc: true }; // S·∫Øp x·∫øp tƒÉng d·∫ßn m·∫∑c ƒë·ªãnh
			}

			allStories.sort((a, b) => {
				let valA = a[key] || "";
				let valB = b[key] || "";
				return sortOrder.asc ? valA.localeCompare(valB) : valB.localeCompare(valA);
			});

			renderStories(allStories);
		}








		
		const storiesPerPage = 15; // S·ªë l∆∞·ª£ng truy·ªán hi·ªÉn th·ªã tr√™n m·ªói trang
		let currentPage = 1;
		let allStories = [];



		function displayPage(page) {
			let storyTable = document.getElementById("storyTable");
			storyTable.innerHTML = "";
			currentPage = page;

			let start = (page - 1) * storiesPerPage;
			let end = start + storiesPerPage;
			let paginatedStories = allStories.slice(start, end);

			paginatedStories.forEach((story, index) => {
				let row = `<tr>
					<td>${start + index + 1}</td>
					<td>${story.title}</td>
					<td>${story.tag}</td>
					<td>${story.author}</td>
					<td>${story.editor}</td>
					<td>${story.status}</td>
					<td><a href="${story.url}" target="_blank">4rum</a></td>
					<td contenteditable="true" onblur="updateReview('${story.id}', this.innerText)">${story.review}</td>
					<td class="delete-btn" onclick="deleteStory('${story.id}')">üóë</td>
				</tr>`;
				storyTable.innerHTML += row;
			});

			updatePagination();
		}

		function updatePagination() {
			let paginationContainer = document.getElementById("pagination");
			paginationContainer.innerHTML = "";
			let totalPages = Math.ceil(allStories.length / storiesPerPage);

			for (let i = 1; i <= totalPages; i++) {
				let btn = document.createElement("button");
				btn.innerText = i;
				btn.className = i === currentPage ? "active" : "";
				btn.onclick = () => displayPage(i);
				paginationContainer.appendChild(btn);
			}
		}


        openDatabase();
    </script>
</body>
</html>
