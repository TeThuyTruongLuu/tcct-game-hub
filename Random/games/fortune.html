<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>L∆∞u tr·ªØ truy·ªán</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #f7f1e3;
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
        }
        .container {
            width: 90%;
            max-width: 1000px;
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        }
        .toggle-container {
            display: flex;
            justify-content: center;
            background: #f7f1e3;
            border-radius: 50px;
            padding: 5px;
            width: fit-content;
            margin: 0 auto 15px;
        }
        .toggle-btn {
            border: none;
            background: none;
            padding: 10px 20px;
            font-size: 16px;
            font-weight: bold;
            color: #6c5ce7;
            cursor: pointer;
            transition: 0.3s ease;
        }
        .toggle-btn.active {
            background: #6c5ce7;
            color: white;
            border-radius: 50px;
            transition: 0.3s ease;
        }
        .section {
            display: none;
        }
        .section.active {
            display: block;
        }
        .input-container {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            align-items: center;
			padding-left: 10px;
			padding-right: 10px;
        }
        .input-container label {
            flex: 1 1 45%;
            font-weight: bold;
            display: flex;
            align-items: center;
        }
        .input-container input, .input-container select {
            flex: 1;
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 5px;
            margin-left: 10px;
        }
		.flex-row {
			display: flex;
			flex-wrap: wrap;
			gap: 15px;
			align-items: center;
			justify-content: space-between;
			padding-bottom: 10px;
			position: relative;
		}

		.flex-row label {
			flex: 1;
			display: flex;
			align-items: center;
			justify-content: space-between;
		}

		.flex-row input, .flex-row select {
			flex: 1;
			padding: 8px;
			border: 1px solid #ccc;
			border-radius: 5px;
			margin-left: 10px;
		}
		.flex-row .tag-input {
			flex: 4;
		}
		.suggestions-box {
			position: absolute;
			top: 100%; /* Xu·ªëng d∆∞·ªõi input */
			left: 0;
			width: 100%;
			background: white;
			border: 1px solid #ccc;
			max-height: 150px;
			overflow-y: auto;
			display: none;
			z-index: 10;
		}

		.suggestions-box div {
			padding: 8px;
			cursor: pointer;
		}

		.suggestions-box div:hover {
			background: #eee;
		}

		.flex-row .rating-input {
			flex: 1;
			display: flex;
			align-items: center;
		}

		.rating-input input {
			margin-right: 10px;
		}
		.wide-input {
			width: 100%;
		}
		button {
			padding: 10px 20px;
			background-color: #6c5ce7;
			color: white;
			border: none;
			border-radius: 5px;
			cursor: pointer;
			font-size: 16px;
			font-weight: bold;
		}
		.button-container {
			display: flex;
			justify-content: center;
			gap: 10px;
			margin-top: 10px;
		}
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
            background: white;
            border-radius: 5px;
            overflow: hidden;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 10px;
            text-align: left;
        }
        th {
            background-color: #dfe6e9;
        }
        .delete-btn {
            cursor: pointer;
            color: red;
            font-weight: bold;
        }
		.pagination {
			display: flex;
			justify-content: center;
			margin-top: 15px;
			gap: 5px;
		}
		.pagination button {
			padding: 8px 12px;
			border: 1px solid #6c5ce7;
			background-color: #f7f1e3;
			color: #6c5ce7;
			cursor: pointer;
			border-radius: 5px;
			font-size: 14px;
		}
		.pagination button.active {
			background-color: #6c5ce7;
			color: white;
		}
		.pagination button:hover {
			background-color: #5a4ae0;
			color: white;
		}

        .section {
            display: none;
        }
        .section.active {
            display: block;
        }
        .input-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        input, select {
            width: 100%;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
        }
        @media (max-width: 600px) {
            table {
                display: block;
                overflow-x: auto;
                white-space: nowrap;
            }
			button {width: 50%;}
			td, th {
				word-wrap: break-word;
				white-space: normal;
			}
			td:nth-child(2) {
				min-width: 120px;
				max-width: 250px;
			}
			td:nth-child(3) {
				min-width: 70px;
				max-width: 100px;
			}

			.table-container {
				overflow-x: auto;
				display: block;
			}
			.toggle-container {
				display: flex;
				justify-content: center;
				width: 100%;
			}
			.toggle-btn {
				flex: 1;
				font-size: 14px;
				padding: 8px;
			}

			.flex-row {
				flex-direction: column;
			}

			.flex-row label {
				width: 100%;
			}

			.button-container {
				flex-direction: column;
				align-items: center;
			}
        }
    </style>
</head>
<body>
   <div class="container">
        <h2>Qu·∫£n l√Ω Truy·ªán</h2>
        <div class="toggle-container">
            <button id="btn-upload" class="toggle-btn active" onclick="toggleSection('upload')">T·∫£i truy·ªán m·ªõi</button>
            <button id="btn-search" class="toggle-btn" onclick="toggleSection('search')">T√¨m truy·ªán</button>
        </div>
        
		<div id="upload" class="section active">
			<div class="flex-row">
				<label>Nh·∫≠p link truy·ªán: <input type="text" id="storyLink"></label>
				<button onclick="fetchStory()">L∆∞u Truy·ªán</button>
			</div>
		<div class="flex-row">
			<label>Tag b·ªï sung:
				<input type="text" id="additionalTags" class="tag-input" oninput="suggestTags(event)" autocomplete="off">
				<div id="tagSuggestions" class="suggestions-box"></div>
			</label>
			<label class="rating-input">ƒê√°nh gi√°: <input type="number" id="rating" min="0" max="10" step="0.5"> / 10</label>
		</div>
			<div class="flex-row">
				<label class="wide-input">Review: <input type="text" id="reviewText"></label>
			</div>
		</div>

		<div id="search" class="section">
			<div class="flex-row">
				<label>Ch·ªçn tag mu·ªën: <input type="text" id="desiredTags"></label>
				<label>Ch·ªçn tag kh√¥ng mu·ªën: <input type="text" id="excludedTags"></label>
			</div>
			<div class="flex-row">
				<label>T√°c gi·∫£: <select id="authorSelect"></select></label>
				<label>Editor: <select id="editorSelect"></select></label>
				<label>Tr·∫°ng th√°i: <select id="statusSelect">
					<option value="">T·∫•t c·∫£</option>
					<option value="Ho√†n">Ho√†n</option>
					<option value="ƒêang c·∫≠p nh·∫≠t">ƒêang c·∫≠p nh·∫≠t</option>
				</select></label>
			</div>
			<div class="button-container">
				<button onclick="randomStory()">Random Truy·ªán</button>
				<button onclick="filterStories()">L·ªçc Truy·ªán</button>
			</div>
		</div>
        <h3>Danh s√°ch truy·ªán ƒë√£ l∆∞u</h3>
        <table>
            <thead>
                <tr>
                    <th onclick="sortTable(0)">STT</th>
                    <th onclick="sortTable(1)">T√™n truy·ªán</th>
                    <th onclick="sortTable(2)">Tag</th>
                    <th>T√°c gi·∫£</th>
                    <th>Edit / Beta</th>
                    <th onclick="sortTable(3)">T√¨nh tr·∫°ng</th>
                    <th>Link</th>
                    <th>Review</th>
                    <th>X√≥a</th>
                </tr>
            </thead>
            <tbody id="storyTable"></tbody>
        </table>
		<div class="pagination" id="pagination"></div>
    </div>

	<script> //K√©o script c·ªßa toggle ra ri√™ng
		window.toggleSection = function(section) {
			document.querySelectorAll('.section').forEach(s => s.classList.remove('active'));
			document.getElementById(section).classList.add('active');
			document.querySelectorAll('.toggle-btn').forEach(b => b.classList.remove('active'));
			document.getElementById('btn-' + section).classList.add('active');
		};
	</script>

    <script type="module">
		import { initializeApp } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-app.js";
		import { getFirestore, collection, addDoc, getDocs, query, where, deleteDoc, doc } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-firestore.js";

		const firebaseConfig = {
			apiKey: "AIzaSyBtpLSSNBj9lHtzibLh5QSRAPg3iQ46Q3g",
			authDomain: "tcct-minigames.firebaseapp.com",
			projectId: "tcct-minigames",
			storageBucket: "tcct-minigames.firebasestorage.app",
			messagingSenderId: "604780847536",
			appId: "1:604780847536:web:f8015bde5ef469b04c7675",
			measurementId: "G-1GGDZR6VY5"
		};

		const app = initializeApp(firebaseConfig);
		const db = getFirestore(app);
		const storiesCollection = collection(db, "stories");

		const dbName = "StoryDB";
		let idb;

		function openDatabase() {
			let request = indexedDB.open(dbName, 1);
			request.onupgradeneeded = function (event) {
				idb = event.target.result;
				if (!idb.objectStoreNames.contains("stories")) {
					idb.createObjectStore("stories", { keyPath: "url" });
				}
			};
			request.onsuccess = function (event) {
				idb = event.target.result;
				loadStories();
			};
			request.onerror = function (event) {
				console.error("Database error:", event.target.error);
			};
		}


		// üöÄ L·∫•y d·ªØ li·ªáu truy·ªán t·ª´ link web
		async function fetchStory() {
			let inputField = document.getElementById("storyLink");
			let url = inputField.value.trim();
			inputField.value = url;

			if (!url) {
				alert("Vui l√≤ng nh·∫≠p link truy·ªán!");
				return;
			}

			const proxyUrl = "https://api.allorigins.win/raw?url=";
			let fetchUrl = proxyUrl + encodeURIComponent(url);

			try {
				let response = await fetch(fetchUrl);
				let text = await response.text();
				let parser = new DOMParser();
				let doc = parser.parseFromString(text, "text/html");

				let titleMatch = doc.querySelector("h1")?.innerText.match(/\[(.*?)\]\s*(\[.*?\])?(.*)/);
				let title = titleMatch ? titleMatch[3].trim() : "Kh√¥ng r√µ";
				let fullTitle = doc.querySelector("h1")?.innerText.trim() || "Kh√¥ng r√µ";
				
				let tagMatches = fullTitle.match(/\[(.*?)\]/g);
				let defaultTag = tagMatches ? tagMatches[tagMatches.length - 1].replace(/\[|\]/g, "") : "Kh√¥ng r√µ";

				let status = doc.querySelector("h1.p-title-value span")?.textContent.trim() || "Kh√¥ng r√µ";
				let author = "Kh√¥ng r√µ";
				let editor = "Kh√¥ng r√µ";

				doc.querySelectorAll("article.message-body.js-selectToQuote div").forEach(div => {
					let text = div.innerText.trim();
					let authorMatch = text.match(/T√°c gi·∫£:\s*(.+)|Author:\s*(.+)/i);
					if (authorMatch) author = authorMatch[1] || authorMatch[2];

					let editorMatch = text.match(/Editor:\s*(.+)|Edit:\s*(.+)|Edit\s*\+\s*beta:\s*(.+)/i);
					if (editorMatch) editor = editorMatch[1] || editorMatch[2] || editorMatch[3];
				});

				editor = editor.replace(/^@/, "").trim();

				let story = {
					title,
					defaultTag,
					userTags: [],
					author,
					editor,
					status,
					url,
					review: {}
				};

				console.log("üìå Truy·ªán ƒë√£ fetch:", story);

				// üöÄ Ki·ªÉm tra xem truy·ªán ƒë√£ t·ªìn t·∫°i trong Firestore ch∆∞a
				let existingStory = await fetchStoryFromFirestore(url);

				if (existingStory) {
					story.userTags = existingStory.userTags || {};
					story.review = existingStory.review || {};
					console.log("üìå Truy·ªán ƒë√£ t·ªìn t·∫°i, c·∫≠p nh·∫≠t tags & review t·ª´ Firestore!");
				}

				// üöÄ Hi·ªÉn th·ªã tag & review l√™n UI
				displayStoryDetails(story);

				await saveStory(story);
			} catch (error) {
				console.error("‚ùå L·ªói khi fetch truy·ªán:", error);
				alert("Kh√¥ng th·ªÉ l·∫•y d·ªØ li·ªáu t·ª´ link n√†y!");
			}
		}

		import { setDoc, getDoc } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-firestore.js";


		// üî• L∆∞u truy·ªán v√†o Firestore + IndexedDB
		function removeVietnameseTones(str) {
			return str.normalize("NFD").replace(/[\u0300-\u036f]/g, "") // B·ªè d·∫•u
				.replace(/ƒë/g, "d").replace(/ƒê/g, "D"); // Chuy·ªÉn ƒë -> d, ƒê -> D
		}
	
	
		async function saveStoryToFirestore(story) {
			try {
				let storyId = removeVietnameseTones(story.title)
					.replace(/[^\w\s]/gi, "")
					.replace(/\s+/g, "_")
					.trim();

				let storyRef = doc(storiesCollection, storyId);

				let existingDoc = await getDoc(storyRef);
				let existingData = existingDoc.exists() ? existingDoc.data() : {};

				let updatedStory = {
					...existingData,
					...story,
					userTags: {
						...(existingData.userTags || {}),
						...(story.userTags || {})
					}
				};

				await setDoc(storyRef, updatedStory, { merge: true });
				console.log("üî• Truy·ªán ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t trong Firestore v·ªõi ID:", storyId);
			} catch (error) {
				console.error("‚ùå L·ªói khi l∆∞u v√†o Firestore:", error);
			}
		}


		function saveStoryToIndexedDB(story) {
			if (!idb) {
				console.warn("‚ö† IndexedDB ch∆∞a s·∫µn s√†ng.");
				return;
			}

			if (!story.url) {
				console.error("üö® L·ªói: Kh√¥ng th·ªÉ l∆∞u truy·ªán v√†o IndexedDB v√¨ thi·∫øu 'url'!");
				return;
			}

			let transaction = idb.transaction(["stories"], "readwrite");
			let store = transaction.objectStore("stories");

			// üî• Ki·ªÉm tra n·∫øu ƒë√£ c√≥ trong IndexedDB
			let getRequest = store.get(story.url);
			getRequest.onsuccess = function (event) {
				let existingStory = event.target.result || {};

				// ‚úÖ Merge d·ªØ li·ªáu ƒë·ªÉ gi·ªØ l·∫°i User Tags
				let updatedStory = {
					...existingStory, // Gi·ªØ th√¥ng tin c≈©
					...story, // C·∫≠p nh·∫≠t th√¥ng tin m·ªõi
					userTags: {
						...(existingStory.userTags || {}), // Gi·ªØ User Tags c≈©
						...(story.userTags || {}) // Th√™m User Tags m·ªõi
					}
				};

				store.put(updatedStory); // Ghi ƒë√® d·ªØ li·ªáu
				console.log("‚úÖ Truy·ªán ƒë√£ ƒë∆∞·ª£c l∆∞u/c·∫≠p nh·∫≠t trong IndexedDB:", updatedStory.url);
			};

			getRequest.onerror = function (event) {
				console.error("‚ùå L·ªói khi truy v·∫•n IndexedDB:", event.target.error);
			};
		}


		async function saveStory(story) {
			try {
				await saveStoryToFirestore(story);
				saveStoryToIndexedDB(story);
				
				await fetchTagsFromDatabase();

				loadStories();
			} catch (error) {
				console.error("‚ùå L·ªói khi l∆∞u truy·ªán:", error);
			}
		}
		window.saveStory = saveStory;


		//Hi·ªÉn th·ªã th√¥ng tin truy·ªán trong b·∫£ng nh·∫≠p sau khi nh·∫•n l∆∞u
		async function fetchStoryFromFirestore(url) {
			let querySnapshot = await getDocs(query(collection(db, "stories"), where("url", "==", url)));

			if (!querySnapshot.empty) {
				return querySnapshot.docs[0].data();
			}
			return null;
		}

		function displayStoryDetails(story) {
			let allTags = [story.defaultTag];
			
			if (story.userTags && typeof story.userTags === "object") {
				Object.values(story.userTags).forEach(tagList => {
					tagList.forEach(tag => allTags.push(tag));
				});
			}

			document.getElementById("additionalTags").value = allTags.join(", ");

			// üöÄ Hi·ªÉn th·ªã t·∫•t c·∫£ review
			let allReviews = [];

			if (story.review && typeof story.review === "object") {
				Object.entries(story.review).forEach(([username, reviews]) => {
					allReviews.push(`${username}: ${reviews.join(", ")}`);
				});
			}

			document.getElementById("reviewText").value = allReviews.join(" | ");
		}
		
		
		
		// üöÄ Load truy·ªán
		async function loadStories() {
			console.log("üì• ƒêang t·∫£i truy·ªán...");

			// üî• 1. Load t·ª´ IndexedDB tr∆∞·ªõc (Nhanh h∆°n, h·ªó tr·ª£ offline)
			let indexedDBStories = await loadStoriesFromIndexedDB();
			let storyMap = {}; // T·∫°o m·ªôt object map ƒë·ªÉ gi·ªØ d·ªØ li·ªáu IndexedDB

			indexedDBStories.forEach(story => {
				storyMap[story.url] = story;
			});

			renderStories(indexedDBStories);
			console.log("‚úÖ Truy·ªán t·∫£i t·ª´ IndexedDB:", indexedDBStories);

			// üî• 2. Sau ƒë√≥, t·∫£i t·ª´ Firestore (n·∫øu c√≥ k·∫øt n·ªëi)
			try {
				let firestoreStories = await getDocs(storiesCollection);
				let stories = [];

				firestoreStories.forEach((doc) => {
					let story = doc.data();
					story.id = doc.id;

					if (storyMap[story.url]) {
						story.userTags = {
							...(storyMap[story.url].userTags || {}),
							...(story.userTags || {})
						};
					}

					stories.push(story);

					saveStoryToIndexedDB(story);
				});

				console.log("üî• Truy·ªán t·∫£i t·ª´ Firestore:", stories);
				renderStories(stories);
			} catch (error) {
				console.error("‚ùå L·ªói khi t·∫£i truy·ªán t·ª´ Firestore:", error);
			}
		}


		function loadStoriesFromIndexedDB() {
			return new Promise((resolve, reject) => {
				if (!idb) {
					resolve([]);
					return;
				}

				let transaction = idb.transaction(["stories"], "readonly");
				let store = transaction.objectStore("stories");
				let request = store.getAll();

				request.onsuccess = function (event) {
					resolve(event.target.result);
				};

				request.onerror = function (event) {
					console.error("L·ªói khi t·∫£i t·ª´ IndexedDB:", event.target.error);
					resolve([]);
				};
			});
		}


		// üöÄ X√≥a truy·ªán
		async function deleteStoryFromFirestore(storyId) {
			await deleteDoc(doc(db, "stories", storyId));
		}


		function deleteStoryFromIndexedDB(storyUrl) {
			let transaction = idb.transaction(["stories"], "readwrite");
			let store = transaction.objectStore("stories");
			store.delete(storyUrl);
		}


		function deleteStory(storyUrl, storyId) {
			// X√≥a kh·ªèi IndexedDB
			deleteStoryFromIndexedDB(storyUrl);

			// N·∫øu c√≥ ID t·ª´ Firestore, x√≥a kh·ªèi Firestore
			if (storyId) {
				deleteStoryFromFirestore(storyId);
			}

			// C·∫≠p nh·∫≠t l·∫°i UI
			setTimeout(() => loadStories(), 500);
		}

		window.deleteStory = deleteStory;
		
		openDatabase();
		window.fetchStory = fetchStory;


		//G·∫Øn tag cho truy·ªán (L·∫•y tag t·ª´ database, g·ª£i √Ω, ch·ªçn tag)
		let allTags = [];

		async function fetchTagsFromDatabase() {
			try {
				let querySnapshot = await getDocs(collection(db, "stories"));
				allTags = new Set(); // D√πng Set ƒë·ªÉ tr√°nh tr√πng tag

				querySnapshot.forEach(doc => {
					let storyData = doc.data();
					if (storyData.defaultTag) allTags.add(storyData.defaultTag); // Th√™m defaultTag
					if (storyData.userTags && typeof storyData.userTags === "object") {
						Object.values(storyData.userTags).forEach(tag => allTags.add(tag)); // Th√™m userTags
					}
				});

				allTags = [...allTags]; // Chuy·ªÉn Set th√†nh Array
				console.log("üìå T·∫•t c·∫£ tag ƒë√£ t·∫£i:", allTags);
			} catch (error) {
				console.error("‚ùå L·ªói khi t·∫£i tag:", error);
			}
		}

		async function loadAllTags() {
			let allTagsSet = new Set();

			// L·∫•y t·∫•t c·∫£ truy·ªán t·ª´ Firestore
			let querySnapshot = await getDocs(collection(db, "stories"));

			querySnapshot.forEach(doc => {
				let story = doc.data();

				// L∆∞u defaultTag
				if (story.defaultTag) {
					allTagsSet.add(story.defaultTag);
				}

				// L∆∞u t·∫•t c·∫£ userTags t·ª´ t·ª´ng user
				if (story.userTags && typeof story.userTags === "object") {
					Object.values(story.userTags).forEach(userTagList => {
						userTagList.forEach(tag => allTagsSet.add(tag));
					});
				}
			});

			// Chuy·ªÉn Set th√†nh Array ƒë·ªÉ s·ª≠ d·ª•ng
			window.allTags = Array.from(allTagsSet);
			console.log("üìå T·∫•t c·∫£ tags ƒë√£ t·∫£i:", window.allTags);
		}

		fetchTagsFromDatabase();
		loadAllTags();
						
		function suggestTags(event) {
			let input = event.target;
			let inputValue = input.value.trim().toLowerCase();
			let suggestionsBox = document.getElementById("tagSuggestions");

			if (!inputValue) {
				suggestionsBox.style.display = "none";
				return;
			}

			// L·ªçc theo t·ª´ng t·ª´ trong tag
			let filteredTags = window.allTags.filter(tag => {
				let words = tag.toLowerCase().split(" "); // T√°ch tag th√†nh t·ª´ng t·ª´
				return words.some(word => word.startsWith(inputValue)); // Ki·ªÉm tra t·ª´ng t·ª´
			});

			if (filteredTags.length === 0) {
				suggestionsBox.style.display = "none";
				return;
			}

			// Hi·ªÉn th·ªã g·ª£i √Ω
			suggestionsBox.innerHTML = "";
			filteredTags.forEach(tag => {
				let suggestion = document.createElement("div");
				suggestion.textContent = tag;
				suggestion.classList.add("suggestion-item");
				suggestion.onclick = () => selectTag(tag);
				suggestionsBox.appendChild(suggestion);
			});

			suggestionsBox.style.display = "block";
		}

		// G·∫Øn s·ª± ki·ªán v√†o √¥ nh·∫≠p tag
		document.getElementById("additionalTags").addEventListener("input", suggestTags);
		window.suggestTags = suggestTags;
		document.addEventListener("click", function(event) {
			if (!event.target.closest("#additionalTags") && !event.target.closest("#tagSuggestions")) {
				document.getElementById("tagSuggestions").style.display = "none";
			}
		});


		function selectTag(tag) {
			let inputField = document.getElementById("additionalTags");
			let existingTags = inputField.value.split(",").map(t => t.trim());
			
			if (!existingTags.includes(tag)) {
				existingTags.push(tag);
			}

			inputField.value = existingTags.join(", ");
			document.getElementById("tagSuggestions").style.display = "none";
		}

		
		async function saveNewTag(storyId, tag) {
			try {
				let storyRef = doc(db, "stories", storyId);
				let storySnap = await getDoc(storyRef);

				if (!storySnap.exists()) {
					console.error("‚ùå Story kh√¥ng t·ªìn t·∫°i, kh√¥ng th·ªÉ th√™m tag.");
					return;
				}

				let existingTags = storySnap.data().userTags || {};
				let username = window.username || "Guest";

				existingTags[username] = tag;

				await setDoc(storyRef, { userTags: existingTags }, { merge: true });

				console.log(`‚úÖ ƒê√£ l∆∞u tag m·ªõi: ${tag} cho story ${storyId}`);
			} catch (error) {
				console.error("‚ùå L·ªói khi l∆∞u tag m·ªõi:", error);
			}
		}


		document.getElementById("additionalTags").addEventListener("input", async function(event) {
			let input = event.target;
			let value = input.value.trim();

			// N·∫øu user nh·∫≠p d·∫•u ",", ki·ªÉm tra v√† l∆∞u tag
			if (value.endsWith(",")) {
				let tag = value.slice(0, -1).trim();

				if (!tag) return;

				let storyURL = document.getElementById("storyLink").value.trim();
				if (!storyURL) {
					console.error("‚ùå Kh√¥ng th·ªÉ th√™m tag: Ch∆∞a nh·∫≠p link truy·ªán!");
					alert("B·∫°n c·∫ßn nh·∫≠p link truy·ªán tr∆∞·ªõc khi th√™m tag.");
					return;
				}

				// T√¨m story trong Firestore
				let querySnapshot = await getDocs(query(collection(db, "stories"), where("url", "==", storyURL)));

				if (querySnapshot.empty) {
					console.error("‚ùå Kh√¥ng t√¨m th·∫•y truy·ªán ƒë·ªÉ c·∫≠p nh·∫≠t tag!");
					alert("Truy·ªán n√†y ch∆∞a ƒë∆∞·ª£c l∆∞u, kh√¥ng th·ªÉ th√™m tag.");
					return;
				}

				// L·∫•y ID c·ªßa truy·ªán
				let storyDoc = querySnapshot.docs[0];
				let storyId = storyDoc.id;

				console.log(`üîç ƒêang th√™m tag "${tag}" v√†o truy·ªán: ${storyId}`);

				// C·∫≠p nh·∫≠t userTags v√†o Firestore
				let username = localStorage.getItem("username") || "Guest"; // L·∫•y username t·ª´ session ho·∫∑c ƒë·ªÉ m·∫∑c ƒë·ªãnh
				let storyRef = doc(db, "stories", storyId);
				let storyData = storyDoc.data();

				let existingTags = storyData.userTags || {};
				existingTags[username] = existingTags[username] ? [...existingTags[username], tag] : [tag];

				await setDoc(storyRef, { userTags: existingTags }, { merge: true });

				console.log(`‚úÖ ƒê√£ l∆∞u tag m·ªõi: "${tag}" cho truy·ªán ${storyId}`);
			}
		});



		//G·∫Øn review cho truy·ªán
		document.getElementById("reviewText").addEventListener("input", async function(event) {
			let input = event.target;
			let value = input.value.trim();

			// N·∫øu user nh·∫≠p d·∫•u ".", ki·ªÉm tra v√† l∆∞u review
			if (value.endsWith(".")) {
				let review = value.slice(0, -1).trim();

				if (!review) return;

				let storyURL = document.getElementById("storyLink").value.trim();
				if (!storyURL) {
					console.error("‚ùå Kh√¥ng th·ªÉ th√™m tag: Ch∆∞a nh·∫≠p link truy·ªán!");
					alert("B·∫°n c·∫ßn nh·∫≠p link truy·ªán tr∆∞·ªõc khi th√™m tag.");
					return;
				}

				// T√¨m story trong Firestore
				let querySnapshot = await getDocs(query(collection(db, "stories"), where("url", "==", storyURL)));

				if (querySnapshot.empty) {
					console.error("‚ùå Kh√¥ng t√¨m th·∫•y truy·ªán ƒë·ªÉ c·∫≠p nh·∫≠t review!");
					alert("Truy·ªán n√†y ch∆∞a ƒë∆∞·ª£c l∆∞u, kh√¥ng th·ªÉ th√™m review.");
					return;
				}

				// L·∫•y ID c·ªßa truy·ªán
				let storyDoc = querySnapshot.docs[0];
				let storyId = storyDoc.id;

				console.log(`üîç ƒêang th√™m review "${review}" v√†o truy·ªán: ${storyId}`);

				// C·∫≠p nh·∫≠t review v√†o Firestore
				let username = localStorage.getItem("username") || "Guest";
				let storyRef = doc(db, "stories", storyId);
				let storyData = storyDoc.data();

				let existingReviews = storyData.review || {};
				existingReviews[username] = existingReviews[username] ? [...existingReviews[username], review] : [review];

				await setDoc(storyRef, { review: existingReviews }, { merge: true });

				console.log(`‚úÖ ƒê√£ l∆∞u review m·ªõi: "${review}" cho truy·ªán ${storyId}`);
			}
		});



		function renderStories(stories) {
			let storyTable = document.getElementById("storyTable");
			storyTable.innerHTML = "";

			stories.forEach((story, index) => {
				// üî• G·ªôp Default Tag v√† User Tags
				let allTags = story.defaultTag || "Kh√¥ng c√≥ tag";

				// üî• L·∫•y User Tags ƒë√∫ng c√°ch
				if (story.userTags && typeof story.userTags === "object") {
					let userTagList = Object.entries(story.userTags) // L·∫•y t·ª´ng c·∫∑p [username, tag]
						.map(([_, tag]) => tag) // Ch·ªâ l·∫•y gi√° tr·ªã tag
						.join(", "); // N·ªëi th√†nh chu·ªói

					if (userTagList) {
						allTags += `, ${userTagList}`;
					}
				}

				let row = `
					<tr>
						<td>${index + 1}</td>
						<td>${story.title}</td>
						<td>${allTags}</td> <!-- ‚úÖ Hi·ªÉn th·ªã ƒë√∫ng tag -->
						<td>${story.author}</td>
						<td>${story.editor}</td>
						<td>${story.status}</td>
						<td><a href="${story.url}" target="_blank">Xem</a></td>
						<td contenteditable="true" onblur="updateReview('${story.url}', this.innerText)">
							${story.review ? Object.values(story.review || {}).join(", ") : ""}
						</td>
						<td class="delete-btn" onclick="deleteStory('${story.url}', '${story.id || ""}')">üóë</td>
					</tr>
				`;
				storyTable.innerHTML += row;
			});
		}

		window.renderStories = renderStories;

    </script>
</body>
</html>
